# Depth-Frist Search 깊이 우선 탐색 O(N)

"""
프로그래밍에서 그래프는 크게 2가지 방식으로 표현
1. 인접 행렬: 2차원 배열로 그래프의 연결 관계를 표현하는 방식 - 파이썬에서는 2차원 리스트로 구현
노드 개수가 많을 수록 불필요한 메모리를 사용

2. 인접 리스트: 리스트로 그래프의 연결 관계를 표현하는 방식- 연결리스트 자료구조 이용
특정한 두 노드가 연결되어 있는지에 대한 정보를 얻는 속도가 느림(연결된 데이터를 하나씩 확인해봐야 함)

특정한 노드와 연결된 모든 인접 노드를 순회해야 하는 경우, 인접 리스트 방식을 사용

DFS 스택 자료구조 이용한 구체적인 동작
1. 탐색 시작 노드를 스택에 삽입하고 방문 처리
2. 스택의 최상단 노드에 방문하지 않은 인접 노드가 있으면 그 인접 노드를 스택에 넣고 방문 처리. 방문하지 않은 인접 노드가 없으면
스택에서 최상단 노드를 꺼냄
3. 2번의과정을 더 이상 수행할 수 없을 때 까지 반복
"""

# 인접 행렬 방식
INF = 9999999999 # 연결이 되어 있지 않은 노드끼리는 무한의 비용이라고 작성

graph = [
    [0,7,5],
    [7,0,INF],
    [5,INF,0]
]

print(graph)
print("#################################")

# 인접 리스트 방식
# 행이 3개인 2차원 리스트로 인접 리스트 표현
graph = [[] for _ in range(3)]
print(graph)
# 노드 0에 연결된 노드 정보 저장(노드, 거리)
graph[0].append((1,7))
graph[0].append((2,5))
print(graph)

# 노드 1에 연결된 노드 정보 저장(노드,거리)
graph[1].append((0,7))
print(graph)
#노드 2
graph[2].append((0,5))
print(graph)
print("#################################")

# 방문 처리를 한 실제 구현 예제
def dfs(graph, v, visited): # v는 노드, visited는 방문 처리여부 최초는 false로 시작
    # 시작점의 노드를 방문 처리
    visited[v] = True
    print(v, end=' ')
    # 현재 노드와 연결된 다른 노드를 재귀적으로 방문
    for i in graph[v]:
        if not visited[i]: # 방문 하지 않은 것만 다시 재귀함수 호출
            dfs(graph, i, visited)

graph = [
    [],
    [2,3,8],
    [1,7],
    [1,4,5],
    [3,5],
    [3,4],
    [7],
    [2,6,8],
    [1,7]
]

# 각 노드가 방문된 정보를 리스트 자료형으로 표현(1차원 리스트)
visited = [False] * 9

# 정의된 DFS 함수 호출 방문하는 노드 순서 출력
dfs(graph, 1, visited)