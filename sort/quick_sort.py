"""
퀵 정렬(Quick Sort)은 평균적으로 매우 빠른 실행 시간을 가지는 비교 기반 정렬 알고리즘입니다.
퀵 정렬의 기본 아이디어는 분할 정복(divide and conquer) 방식을 통해 큰 문제를 작은 문제로 나누어 해결하는 것입니다.
이 알고리즘의 핵심은 '피벗(pivot)'을 사용하여 배열을 분할하는 것이며,
피벗을 기준으로 피벗보다 작은 모든 요소는 피벗의 왼쪽에, 큰 모든 요소는 피벗의 오른쪽에 위치하도록 배열을 재배치

1. 피벗 선택: 배열에서 하나의 요소를 피벗으로 선택합니다. 피벗 선택 방법은 다양하지만, 간단한 방법으로는 첫 번째 요소, 마지막 요소, 중간 요소 또는 무작위 요소를 선택할 수 있습니다.
2. 분할: 선택된 피벗을 기준으로 배열을 두 부분으로 나눕니다. 피벗보다 작은 모든 요소는 피벗의 왼쪽에, 피벗보다 큰 모든 요소는 피벗의 오른쪽에 오도록 합니다. 이 과정에서 피벗은 최종적으로 정렬된 위치에 있게 됩니다.
3. 정복: 피벗을 제외한 왼쪽 부분과 오른쪽 부분 각각에 대해 재귀적으로 위의 과정을 반복합니다.
4. 결합: 퀵 정렬은 분할 시 요소들이 이미 정렬되는 방식이므로, 별도의 결합 과정이 필요 없습니다.

* 평균 시간 복잡도: O(n log n). 피벗이 균등하게 분할되는 경우에 해당합니다.
* 최악 시간 복잡도: O(n^2). 피벗이 항상 최소값이나 최대값으로 선택되어 분할이 불균형하게 이루어지는 경우에 해당합니다.
* 장점: 추가적인 메모리를 거의 사용하지 않으며, 평균적으로 매우 빠른 실행 속도를 가집니다.
* 단점: 최악의 경우 시간 복잡도가 O(n^2)까지 증가할 수 있습니다. 또한, 안정 정렬(stable sort)이 아니므로 동일한 값을 가진 요소의 상대적 순서가 변경될 수 있습니다.
"""

def quickSort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quickSort(left) + middle + quickSort(right)

# 예시 배열
arr = [3, 6, 8, 10, 1, 2, 1]
sorted_arr = quickSort(arr)
print("정렬된 배열:", sorted_arr)