"""
힙 정렬(Heap Sort)은 선택 정렬을 개선한 정렬 방식 중 하나로,
완전 이진 트리를 이용한 최대 힙(Max Heap)이나 최소 힙(Min Heap) 트리 구조를 활용하여 배열을 정렬하는 방법입니다.
이 알고리즘의 핵심은 모든 부모 노드가 자신의 자식 노드보다 큰 값을 갖는 최대 힙 특성을 이용하여
배열의 최댓값(또는 최솟값)을 쉽게 추출할 수 있다는 점

힙 구성(Heapify): 주어진 배열로부터 최대 힙을 구성합니다. 이 과정은 배열의 중간부터 시작하여 처음까지 역순으로 진행하며, 각 요소에 대하여 하위 힙을 최대 힙으로 만드는 작업을 반복합니다.
정렬 실행: 최대 힙의 루트(가장 큰 값)와 마지막 요소를 교환한 뒤, 마지막 요소를 제외한 나머지 힙에 대해 다시 힙 구성 과정을 실행합니다. 이 과정을 배열의 모든 요소가 정렬될 때까지 반복합니다.

* 시간 복잡도: 평균 및 최악의 경우 모두 O(n log n)
* 공간 복잡도: O(1), 추가 배열을 사용하지 않고 주어진 배열 내에서 정렬을 수행합니다.
* 안정성: 힙 정렬은 불안정 정렬에 속합니다. 같은 값의 요소가 있을 경우, 원래의 순서가 유지되지 않을 수 있습니다.
* 효율성: 대용량 데이터 처리에 적합하며, 추가적인 메모리 할당 없이 빠른 정렬이 가능합니다.

* 시간 복잡도: 모든 경우에 O(n log n)을 보장합니다. 따라서 데이터의 양이 많아도 성능이 급격히 떨어지지 않습니다.
* 공간 효율성: 추가적인 메모리를 거의 사용하지 않으멀로, 공간 복잡도가 낮습니다. 이는 in-place 정렬 방식으로, 주어진 배열 안에서 정렬을 수행한다는 의미입니다.
* 최악의 경우에도 안정적인 성능: 최악의 경우에도 O(n log n)의 시간 복잡도를 유지합니다.
"""

def heapify(arr, n, i):
    largest = i  # 루트를 최대값으로 가정
    l = 2 * i + 1  # 왼쪽 자식
    r = 2 * i + 2  # 오른쪽 자식

    # 왼쪽 자식이 루트보다 크다면
    if l < n and arr[l] > arr[largest]:
        largest = l

    # 오른쪽 자식이 현재 최대값보다 크다면
    if r < n and arr[r] > arr[largest]:
        largest = r

    # 최대값이 루트가 아니라면
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]  # 교환

        # 교환된 루트에 대해 다시 힙 구성
        heapify(arr, n, largest)

def heapSort(arr):
    n = len(arr)

    # 초기 최대 힙 구성
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)

    # 하나씩 원소를 꺼내어 다시 최대 힙 구성
    for i in range(n-1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]  # 루트와 마지막 요소 교환
        heapify(arr, i, 0)

# 예시 배열
arr = [12, 11, 13, 5, 6, 7]
heapSort(arr)
print("정렬된 배열은", arr)
