"""
선택 정렬(Selection Sort)은 배열이나 리스트를 정렬하는 간단한 비교 기반 알고리즘입니다.
기본 원리는 전체 배열을 순회하며 각 위치에 올바른 값을 찾아서 배치하는 것입니다.
이 과정은 배열의 모든 요소가 올바르게 정렬될 때까지 반복됩니다.
선택 정렬은 그 구현의 단순함으로 인해 작은 리스트에 대해서는 효율적일 수 있지만,
대규모 데이터 세트에 대해서는 다른 더 효율적인 정렬 알고리즘에 비해 성능이 떨어집니다.

1. 최소값 탐색: 배열 전체에서 최소값을 탐색합니다.
2. 스왑(swap): 최소값을 배열의 현재 위치와 교체합니다. 처음에는 배열의 첫 번째 위치에서 시작합니다.
3. 다음 위치로 이동: 현재 위치를 한 칸 옮기고 남은 배열에 대해 최소값을 다시 탐색합니다.
4. 반복: 위의 과정을 배열의 모든 요소가 올바르게 정렬될 때까지 반복합니다.

* 비교 횟수: 배열의 크기가 n일 때, 약 n(n-1)/2번의 비교가 이루어집니다. 이는 선택 정렬의 시간 복잡도가 O(n^2)임을 의미합니다.
* 스왑 횟수: 선택 정렬은 비교 횟수에 비해 상대적으로 교환(swap) 횟수가 적다는 특징이 있습니다. 최악의 경우에도 n-1번의 교환만을 수행합니다.
* 안정성: 선택 정렬은 안정적인 정렬 방법이 아닙니다. 즉, 값이 같은 레코드가 입력에 있을 경우, 그 순서가 정렬 후에도 유지되지 않을 수 있습니다.
* 메모리 사용: 선택 정렬은 추가적인 메모리 공간을 거의 사용하지 않으므로, 인플레이스(in-place) 정렬 알고리즘으로 분류됩니다.
"""
# 가장 작은 수를 찾아서 맨앞으로 배치시키는 정렬
def selection_sort(arr):
    n = len(arr)
    for i in range(n):
        min_idx = i
        for j in range(i+1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
        print(arr)
    return arr

arr = [64, 34, 25, 12, 22, 11, 90]
selection_sort(arr)
print("Sorted array is:", arr)